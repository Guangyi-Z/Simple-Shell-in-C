!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CC	Makefile	/^CC=gcc$/;"	m
CMD_MAXLEN	parser.h	2;"	d
HDREXTS	Makefile	/^HDREXTS= .h .H$/;"	m
MAXARGS	parser.h	1;"	d
MYCTAGS	Makefile	/^MYCTAGS=-c -g  $/;"	m
MYLIBS	Makefile	/^MYLIBS=$/;"	m
OBJS	Makefile	/^    OBJS    = $(addsuffix .o, $(basename $(SOURCES)))  $/;"	m
PROGRAM	Makefile	/^PROGRAM=a.out$/;"	m
SOURCES	Makefile	/^    SOURCES = $(foreach d,$(SRCDIRS),$(wildcard $(addprefix $(d)\/*,$(SRCEXTS))))  $/;"	m
SRCDIRS	Makefile	/^SRCDIRS= .$/;"	m
SRCEXTS	Makefile	/^SRCEXTS= .c .C$/;"	m
argv	parser.h	/^  char *argv[MAXARGS];   \/\/ arguments to the command to be exec-ed$/;"	m	struct:execcmd
cmd	parser.h	/^  struct cmd *cmd;   \/\/ the command to be run (e.g., an execcmd)$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd
cmd	parser.h	/^struct cmd {$/;"	s
die	parser.h	4;"	d
die	sh.c	9;"	d	file:
execcmd	parser.c	/^execcmd(void)$/;"	f
execcmd	parser.h	/^struct execcmd {$/;"	s
fd	parser.h	/^  int fd;            \/\/ the file descriptor number to use for the file$/;"	m	struct:redircmd
file	parser.h	/^  char *file;        \/\/ the input\/output file$/;"	m	struct:redircmd
fork1	parser.c	/^fork1(void)$/;"	f
getcmd	parser.c	/^getcmd(char *buf, int nbuf)$/;"	f
gettoken	parser.c	/^gettoken(char **ps, char *es, char **q, char **eq)$/;"	f
istoks	util.c	/^istoks(char *s, char *toks)$/;"	f
left	parser.h	/^  struct cmd *left;  \/\/ left side of pipe$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd
main	sh.c	/^main(void)$/;"	f
mkcopy	util.c	/^mkcopy(char *s, char *es)$/;"	f
mode	parser.h	/^  int mode;          \/\/ the mode to open the file with$/;"	m	struct:redircmd
parsecmd	parser.c	/^parsecmd(char *s)$/;"	f
parseexec	parser.c	/^parseexec(char **ps, char *es){$/;"	f
parseline	parser.c	/^parseline(char **ps, char *es)$/;"	f
parsepipe	parser.c	/^parsepipe(char **ps, char *es)$/;"	f
parseredirs	parser.c	/^parseredirs(struct cmd *cmd, char **ps, char *es)$/;"	f
peek	util.c	/^peek(char **ps, char *es, char *toks)$/;"	f
pipecmd	parser.c	/^pipecmd(struct cmd *left, struct cmd *right)$/;"	f
pipecmd	parser.h	/^struct pipecmd {$/;"	s
redircmd	parser.c	/^redircmd(struct cmd *subcmd, char *file, int type)$/;"	f
redircmd	parser.h	/^struct redircmd {$/;"	s
right	parser.h	/^  struct cmd *right; \/\/ right side of pipe$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd
runcmd	parser.c	/^runcmd(struct cmd *cmd)$/;"	f
scan	util.c	/^scan(char **ps, char *es, const char *toks, char **q, char **eq){$/;"	f
searchfile	util.c	/^searchfile(char *file, int len, char* name, int mode){$/;"	f
skip_whitespace	util.c	/^skip_whitespace(char **ps, char *es)$/;"	f
symbols	parser.c	/^char symbols[] = "<|>";$/;"	v
type	parser.h	/^  int type;              \/\/ ' '$/;"	m	struct:execcmd
type	parser.h	/^  int type;          \/\/  ' ' (exec), | (pipe), '<' or '>' for redirection$/;"	m	struct:cmd
type	parser.h	/^  int type;          \/\/ < or >$/;"	m	struct:redircmd
type	parser.h	/^  int type;          \/\/ |$/;"	m	struct:pipecmd
whitespace	util.c	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	v
whitespace	util.h	/^char whitespace[];$/;"	v
